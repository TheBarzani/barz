[class, class, 2] [id, CLAS, 2] [lcurbr, {, 2]
[public, public, 3] [attribute, attribute, 3] [id, x, 3] [colon, :, 3] [int, int, 3] [lsqbr, [, 3] [intlit, 10, 3] [rsqbr, ], 3] [lsqbr, [, 3] [intlit, 1, 3] [rsqbr, ], 3] [semi, ;, 3]
[public, public, 4] [attribute, attribute, 4] [id, y, 4] [colon, :, 4] [int, int, 4] [semi, ;, 4]
[rcurbr, }, 5] [semi, ;, 5]
[class, class, 7] [id, CLASS, 7] [lcurbr, {, 7]
[public, public, 8] [attribute, attribute, 8] [id, x, 8] [colon, :, 8] [int, int, 8] [lsqbr, [, 8] [intlit, 10, 8] [rsqbr, ], 8] [lsqbr, [, 8] [intlit, 1, 8] [rsqbr, ], 8] [semi, ;, 8]
[public, public, 9] [attribute, attribute, 9] [id, y, 9] [colon, :, 9] [int, int, 9] [semi, ;, 9]
[public, public, 10] [attribute, attribute, 10] [id, clas, 10] [colon, :, 10] [id, CLAS, 10] [semi, ;, 10]
[rcurbr, }, 11] [semi, ;, 11]
[function, function, 13] [id, hi, 13] [lpar, (, 13] [id, a, 13] [colon, :, 13] [int, int, 13] [lsqbr, [, 13] [intlit, 5, 13] [rsqbr, ], 13] [comma, ,, 13] [id, b, 13] [colon, :, 13] [int, int, 13] [comma, ,, 13] [id, c, 13] [colon, :, 13] [int, int, 13] [lsqbr, [, 13] [intlit, 10, 13] [rsqbr, ], 13] [lsqbr, [, 13] [intlit, 9, 13] [rsqbr, ], 13] [rpar, ), 13] [arrow, =>, 13] [int, int, 13]
[lcurbr, {, 14]
[inlinecmt, //local b: CLASS;, 15]
[inlinecmt, //local x: CLASS[4];, 16]
[inlinecmt, //x[1] := b;, 17]
[rcurbr, }, 18]
[function, function, 21] [id, main, 21] [lpar, (, 21] [rpar, ), 21] [arrow, =>, 21] [void, void, 21]
[lcurbr, {, 22]
[local, local, 24] [id, x, 24] [colon, :, 24] [int, int, 24] [lsqbr, [, 24] [intlit, 5, 24] [rsqbr, ], 24] [lsqbr, [, 24] [intlit, 4, 24] [rsqbr, ], 24] [lsqbr, [, 24] [intlit, 3, 24] [rsqbr, ], 24] [semi, ;, 24]
[id, x, 25] [lsqbr, [, 25] [intlit, 1, 25] [rsqbr, ], 25] [lsqbr, [, 25] [intlit, 2, 25] [rsqbr, ], 25] [lsqbr, [, 25] [intlit, 3, 25] [rsqbr, ], 25] [assign, :=, 25] [intlit, 33, 25] [semi, ;, 25]
[inlinecmt, //write(x[1][2][3]);, 26]
[local, local, 28] [id, cc, 28] [colon, :, 28] [id, CLASS, 28] [semi, ;, 28]
[id, cc, 29] [dot, ., 29] [id, clas, 29] [dot, ., 29] [id, y, 29] [assign, :=, 29] [intlit, 9, 29] [semi, ;, 29]
[id, cc, 30] [dot, ., 30] [id, y, 30] [assign, :=, 30] [intlit, 10, 30] [semi, ;, 30]
[id, cc, 31] [dot, ., 31] [id, x, 31] [lsqbr, [, 31] [intlit, 10, 31] [rsqbr, ], 31] [lsqbr, [, 31] [intlit, 10, 31] [rsqbr, ], 31] [assign, :=, 31] [intlit, 1, 31] [semi, ;, 31]
[local, local, 34] [id, z, 34] [colon, :, 34] [int, int, 34] [semi, ;, 34]
[inlinecmt, //z := x[3][2][1];, 35]
[local, local, 36] [id, a, 36] [colon, :, 36] [int, int, 36] [semi, ;, 36]
[local, local, 37] [id, b, 37] [colon, :, 37] [int, int, 37] [semi, ;, 37]
[id, a, 38] [assign, :=, 38] [id, b, 38] [semi, ;, 38]
[local, local, 40] [id, f, 40] [colon, :, 40] [float, float, 40] [semi, ;, 40]
[local, local, 41] [id, c1, 41] [colon, :, 41] [id, CLASS, 41] [lsqbr, [, 41] [intlit, 3, 41] [rsqbr, ], 41] [semi, ;, 41]
[local, local, 42] [id, c2, 42] [colon, :, 42] [id, CLASS, 42] [semi, ;, 42]
[id, c2, 43] [assign, :=, 43] [id, c1, 43] [lsqbr, [, 43] [intlit, 1, 43] [rsqbr, ], 43] [semi, ;, 43]
[inlinecmt, //write(z);, 45]
[rcurbr, }, 47]
[blockcmt, /*\n// ======================== struct declarations ============================== //\nclass POLYNOMIAL {\n  public function evaluate (x: int) => int;                    \n};\n\nclass LINEAR isa POLYNOMIAL {\n  private attribute a: float;\n  private attribute b: float;\n  public  function build(A: float, B: float) => LINEAR;\n  public  function evaluate(x: float) => float;\n};\n\nclass QUADRATIC isa POLYNOMIAL {\n  private attribute a: float;\n  private attribute b: float;\n  private attribute c: float[2][3];\n  public  function evaluate(x: float) => float;\n  public  function build(A: float, B: float, C: float) => QUADRATIC;\n};\n\n// ====== member function implementations ====== //  \nimplementation POLYNOMIAL {\n  function evaluate(x: int) => int                              // 2.1, 2.2\n  {\n    return (0);                                                   // 2.3\n  }\n}\n\nimplementation LINEAR {\n  function build(A: float, B: float) => LINEAR                      // 2.1, 2.2\n  {\n    local c : int;\n    c := 1+1;\n    local new_function: LINEAR;                                     // 1.1\n    new_function.a := A;                                            // 3.1, 5.3\n    new_function.b := B;                                            // 3.1, 5.3\n    a := A;\n    return (new_function);\n  }\n\n  function evaluate(x: float) => float                              // 2.1, 2.2\n  {\n    local result: float;                                            // 1.1\n    result := 0.0;                                                  // 3.1\n    result := a * x + b;                                            // 3.1, 5.1\n    return (result);                                                // 2.3\n  }\n}\n\nimplementation QUADRATIC { \n  function evaluate(x: float) => float\n  {\n    local result: float;                                            // 1.1\n    result := a;                                                    // 3.1       \n    result := result * x + b;                                       // 3.1, 5.1\n    result := result * x + c[1][1];                                       // 3.1, 5.1\n    return (result);                                                // 2.3\n  }\n\n  function build(A: float, B: float, C: float) => QUADRATIC         // 2.1, 2.2\n  {\n    local new_function: QUADRATIC ;                                 // 1.1\n    new_function.a := A;                                            // 3.1, 5.3\n    new_function.b := B;                                            // 3.1, 5.3\n    new_function.c[1][1] := C;                                            // 3.1, 5.3\n    return (new_function);\n  }\n}\n\n// ====== main ====== //\nfunction main() => void                                             // 2.1, 2.2\n{\n  local arr: int[2][3][5];\n  local f1: LINEAR;                                                 // 1.3, 2.1, 2.2, 2.4\n  local f2: QUADRATIC;                                              // 1.3, 2.1, 2.2, 2.4\n  local counter: int;                                               // 1.1\n  f1 := f1.build(2.0, 3.5);\n  f2 := f2.build(-2.0, 1.0, 0.0);\n  counter := 1;                                                     // 3.1\n	\n  while(counter <= 10)                                              // 3.3, 5.1 \n  {\n    write(counter);                                                 // 3.4\n    write(f1.evaluate(1.0));                                    // 3.4, 2.1, 2.2, 2.4\n    write(f2.evaluate(1.0));                                    // 3.4, 2.1, 2.2, 2.4\n    counter := counter + 1;                                          // 3.1\n  };\n}*/, 49]

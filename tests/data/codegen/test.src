
/*class CLASS {
  public attribute x: int[10][1];
};

function hi(a: int[5], b: int, c: int[10][9]) => int  
{
  //local b: CLASS;
  //local x: CLASS[4];
  //x[1] := b;
}


function main() => void  
{

  /*local x: int[5][4][3];
  x[1][2][3] := 33;
  write(x[1][2][3]);

  
  local z: int;
  z := x[3][2][1];
  local a: int;
  local b: int;
  a:=b;*/

  local f : float;
  local c1: CLASS[3];
  local c2: CLASS;
  c2 := c1[1];

  // write(z);
  
}*/


// ======================== struct declarations ============================== //
class POLYNOMIAL {
  public function evaluate (x: int) => int;                    
};

class LINEAR isa POLYNOMIAL {
  private attribute a: float;
  private attribute b: float;
  public  function build(A: float, B: float) => LINEAR;
  public  function evaluate(x: float) => float;
};

class QUADRATIC isa POLYNOMIAL {
  private attribute a: float;
  private attribute b: float;
  private attribute c: float[2][3];
  public  function evaluate(x: float) => float;
  public  function build(A: float, B: float, C: float) => QUADRATIC;
};

// ====== member function implementations ====== //  
implementation POLYNOMIAL {
  function evaluate(x: int) => int                              // 2.1, 2.2
  {
    return (0);                                                   // 2.3
  }
}

implementation LINEAR {
  function build(A: float, B: float) => LINEAR                      // 2.1, 2.2
  {
    local c : int;
    c := 1+1;
    local new_function: LINEAR;                                     // 1.1
    new_function.a := A;                                            // 3.1, 5.3
    new_function.b := B;                                            // 3.1, 5.3
    a := A;
    return (new_function);
  }

  function evaluate(x: float) => float                              // 2.1, 2.2
  {
    local result: float;                                            // 1.1
    result := 0.0;                                                  // 3.1
    result := a * x + b;                                            // 3.1, 5.1
    return (result);                                                // 2.3
  }
}

implementation QUADRATIC { 
  function evaluate(x: float) => float
  {
    local result: float;                                            // 1.1
    result := a;                                                    // 3.1       
    result := result * x + b;                                       // 3.1, 5.1
    result := result * x + c[1][1];                                       // 3.1, 5.1
    return (result);                                                // 2.3
  }

  function build(A: float, B: float, C: float) => QUADRATIC         // 2.1, 2.2
  {
    local new_function: QUADRATIC ;                                 // 1.1
    new_function.a := A;                                            // 3.1, 5.3
    new_function.b := B;                                            // 3.1, 5.3
    new_function.c[1][1] := C;                                            // 3.1, 5.3
    return (new_function);
  }
}

// ====== main ====== //
function main() => void                                             // 2.1, 2.2
{
  local arr: int[2][3][5];
  local f1: LINEAR;                                                 // 1.3, 2.1, 2.2, 2.4
  local f2: QUADRATIC;                                              // 1.3, 2.1, 2.2, 2.4
  local counter: int;                                               // 1.1
  f1 := f1.build(2.0, 3.5);
  f2 := f2.build(-2.0, 1.0, 0.0);
  counter := 1;                                                     // 3.1
	
  while(counter <= 10)                                              // 3.3, 5.1 
  {
    write(counter);                                                 // 3.4
    write(f1.evaluate(1.0));                                    // 3.4, 2.1, 2.2, 2.4
    write(f2.evaluate(1.0));                                    // 3.4, 2.1, 2.2, 2.4
    counter := counter + 1;                                          // 3.1
  };
}